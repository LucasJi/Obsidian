## 在使用 Git 推送代码时，如果需要修改某个 committed 的 message，该如何操作？如果需要更换 commit 的顺序呢？

### 修改某个 committed 的 message

```shell
# 1. 找到需要修改的 commit 的前一条 commit 的 hash
git log 
# 2. 使用 rebase -i 命令将当前分支 rebase 到目标 commit 前一条 commit
git rebase pre-commit-hash -i
# 3. 在交互式列表中将目标 commit 的命令从 pick 改为 r
# 4. 按ESC退出编辑模式，按:，输入wq<CR>
# 5. 按 i 进入编辑模式，修改目标 commit 的信息。按ESC退出编辑模式，按:，输入wq<CR>，完成全部操作
```

### 更换 commit 顺序

> 说明：vi 编辑器相关操作在前一节已有涉及，此处不再赘述。

利用 `git rebase -i` 命令，rebase 到需要调整顺序的 commit 的前一个 commit。在出现的交互式列表中调整 commit 的顺序并保存退出。此时如果有 conflict，需要解决掉冲突之后，使用 `git rebase --continue` 命令继续 rebase 直至成功完成 commit 顺序调整操作。

## 在接入第三方的 HTTP 接口的场景中，通常需要定义响应结果的数据结构体，使用 Java 中的原始类型与包装类型有何差异，请按照你的理解写出两者的优劣势

### 原始类型

#### 优势

- 直接存贮数据值，没有额外对象开销

#### 劣势

- 具有初始值，因此无法表示 `null` 值。在某些情况下可能对业务产生影响

### 包装类型

#### 优势

- 能够表示 `null` 值，业务表达上更明确，减少二义性
- 支持泛型

#### 劣势

- 性能对比原始类型稍弱，因为涉及对象的开销
- 可能存在空指针异常

## 是否了解 Java 库中的 POJO 映射框架，请至少写出其中一个的大致原理

常用的映射框架为 MapStruct

### 大致原理

1. 通过注解和接口，描述 POJO 映射逻辑
2. 通过 Java 注解处理器在编译期扫描并处理注解生成映射接口的实现类字节码文件

## Java 的 record 有什么特性，或者说明一下其使用场景？

Java 的 record 被创建出来主要是为了方便地表示一些不可变的数据。

1. 利用 Java Bean 的方式创建不可变数据对象，需要写一堆模板代码（包含全部参数的构造函数、getter 方法、toString 方法、equals 方法、hashCode 方法）。如果遇上数据结构的改变（减少或者增加某些属性），这些模板代码也需要做相应的改动，十分繁琐。当使用 record 时，就不需要担忧这个问题了，因为 Java 会自动创建这些模板方法。
2. record 方便于描述不可变数据，因为它的成员变量都被 final 隐性地修饰

## 实现数据的异构有哪些方案，或者结合项目经历说明一下异构数据库的使用场景和管理方式

## 如何在线上进行调试，定位 JVM 的问题，最好结合自身经历描述一下

## 在 Kubernetes 集群中，如何针对 pod 资源实施健康监测

k8s 提供了三类探针来监测 pod 的健康状况

- livenessProbe：判断容器是否处于 Running 状态，以此决定该 pod 是否需要重启
- ReadinessProbe：判断容器是否处于 Ready 状态，以此决定后续请求是否会调度到该 pod
- startupProbe：保护慢启动 pod，防止 pod 因为启动时间过长被上述两类 probe 影响  
上述探针可以使用 http 请求，因此相应 pod 可以配置这些探针对于的端口来方便 k8s 进行健康监测。以 SpringBoot 为例，SpringBoot 中的 Actuator 模块就提供相应的端口来反应 SpringBoot 应用的健康状况。

## 场景设计题目

峰谷类型

```java
/**  
 * 电价四种峰谷类型  
 */  
public enum ElectricityPriceType {  
  /**  
   * 尖  
   */  
  SHARP,  
  /**  
   * 峰  
   */  
  PEAK,  
  /**  
   * 平  
   */  
  SHOULDER,  
  /**  
   * 谷  
   */  
  OFF_PEAK  
}
```

电价表条目

```java
/**  
 * 电价表条目  
 *  
 * @param timePeriodStart 开始时段  
 * @param timePeriodEnd   结束时段  
 * @param priceType       电价峰谷类型  
 * @param price           电价  
 */  
public record ElectricityPriceSetItem(  
  LocalDateTime timePeriodStart,  
  LocalDateTime timePeriodEnd,  
  ElectricityPriceType priceType,  
  BigDecimal price) {  
  
  public ElectricityPriceSetItem(LocalDateTime timePeriodStart,  
    LocalDateTime timePeriodEnd,  
    ElectricityPriceType priceType,  
    BigDecimal price) {  
    if (timePeriodEnd.isBefore(timePeriodStart)) {  
      this.timePeriodStart = timePeriodEnd;  
      this.timePeriodEnd = timePeriodStart;  
    } else {  
      this.timePeriodStart = timePeriodStart;  
      this.timePeriodEnd = timePeriodEnd;  
    }  
    this.priceType = priceType;  
    this.price = price;  
  }  
}
```

电价表

```java
/**  
 * 电价表  
 * <p>  
 * 使用 {@link TreeSet} 是不确定充放电策略的具体是否需要电价表按条目的时间排序，如不需要可以简化为 {@link java.util.Set}  
 *  
 * @param items 电价表条目  
 */
public record ElectricityPriceSet(TreeSet<ElectricityPriceSetItem> items) {  
  
  public ElectricityPriceSet(TreeSet<ElectricityPriceSetItem> items) {  
    TreeSet<ElectricityPriceSetItem> set = defaultSet();  
    set.addAll(items);  
    this.items = set;  
  }  
  
  public static ElectricityPriceSet init() {  
    return new ElectricityPriceSet(defaultSet());  
  }  
  
  private static TreeSet<ElectricityPriceSetItem> defaultSet() {  
    return new TreeSet<>(Comparator.comparing(ElectricityPriceSetItem::timePeriodStart));  
  }  
}
```

一天的充放电计划

```java
/**  
 * 一天的充放电计划  
 */  
public class ChargeAndDischargePlan {  
  // TODO 根据业务定义该类的数据结构  
}
```

充放电策略

```java
/**  
 * 充放电策略  
 */  
public interface ChargeAndDischargeStrategy {  
  
  /**  
   * 生成充放电计划  
   *  
   * @param set 电价表  
   * @return 充放电计划  
   */  
  ChargeAndDischargePlan generatePlan(ElectricityPriceSet set);  
}
```
