## Redis 常用的缓存读写模式

### Cache Aside Pattern - 旁路缓存模式

适合读请求比较多的场景

写：

1. 更新 db
2. 删除缓存  

读：

1. 从缓存中读取数据，读到就返回
2. 缓存中不存在数据就从 db 中读取
3. 将 db 中的数据放入缓存中

#### 缺点

- 首次请求不存在缓存数据（可以将热点数据提前放入缓存中）
- 写操作比较频繁的话，导致缓存经常被删除，影响命中率（更新 db 的时候同样更新缓存）

#### 常见问题

##### 可以先删除缓存，再更新 db 吗

不可以，因为会存在你在更新 db 的时候，另一个线程读这条数据，将缓存更新回去了

##### 先更新 db 后删除缓存就没问题了吗

也存在出现问题的概率。请求一读取数据，请求二更新 db（此时缓存中没有数据，因此不执行更新操作），请求一将未更新前的数据存入缓存中。

### Write Through - 读写穿透

服务端把缓存作为主要数据存储，缓存服务端负责将数据持久化。

写：

1. 先查缓存，缓存不存在的话直接更新数据库
2. 缓存中存在，则直接更新缓存，然后由缓存去同步数据库

读：

1. 从缓存中读到就直接返回
2. 读取不到的话，先从数据库中加载，写入到缓存之后返回响应

### Write Behind Pattern - 异步缓存写入

和读写穿透的思想类似，区别是异步缓存写入不同步更新数据库，而是由缓存服务器去异步定时批量更新数据库。适合对数据一致性要求没那么高的场景。

## 常见的数据结构

基础数据类型

- String
- List
- Set
- Hash
- Zset

特殊数据类型

- HyperLogLogs
- Bitmap
- Geospatial

## Redis 单线程模型

Redis 通过 IO 多路复用程序，来监听来自客户端的大量连接。它会将感兴趣的事件和类型注册到内核中并监听该事件是否发生。

## 过期数据删除策略

1. 惰性删除：在读取 key 的时候判断是否过期，对 CPU 友好但是对内存不友好
2. 定期删除：定期删除过期 key，对内存友好但是对 CPU 不友好  
Redis 采用两种方式组合来对过期数据进行删除。即使这种组合策略，也会造成很多过期 key 未被及时删除，这时候就要利用 Redis 的内存淘汰机制了。

## Redis 性能优化

1. 使用批量操作减少网络传输和 IO 次数
2. 大量 key 集中过期，可以设置随机过期时间

## 生产问题

### 缓存穿透

大量 key 不存在缓存中也不存在数据库中，因此请求直接到达数据库，对数据库造成很大的压力。

解决办法：

1. 布隆过滤器
2. 限流
3. 缓存无效的 key

### 缓存击穿

热点数据存在于数据库中但是不存在于缓存（key 过期了）。

解决办法：

1. 设置热点数据永不过期或者过期时间较长
2. 针对热点数据提前预热，将其存入缓存并设置合理的过期时间
3. 请求数据库写数据到缓存时，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力

### 缓存雪崩

同一时间大量 key 同时过期，导致大量请求直接到达数据库。

解决办法：

1. 使用 Redis 集群
2. 对大量请求进行限流
3. 多级缓存
